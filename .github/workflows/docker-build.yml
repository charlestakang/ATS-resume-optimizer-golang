name: Docker Build & Push

on:
  push:
    branches: [ main, dev, develop, release/* ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ main, dev, develop ]
  workflow_dispatch:
    inputs:
      image_tag:
        description: 'Custom image tag'
        required: false
        default: 'latest'
      push_to_registry:
        description: 'Push to container registry'
        required: false
        default: 'false'
        type: boolean

permissions:
  contents: read
  packages: write
  security-events: write

env:
  REGISTRY: ghcr.io
  REGISTRY_USERNAME: ${{ github.actor }}
  REGISTRY_PASSWORD: ${{ secrets.GITHUB_TOKEN }}
  IMAGE_PREFIX: resumesync
  DOCKER_BUILDKIT: 1
  COMPOSE_DOCKER_CLI_BUILD: 1

concurrency:
  group: docker-build-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # ============================================
  # Build Configuration Matrix
  # ============================================
  prepare-matrix:
    name: Prepare Build Matrix
    runs-on: ubuntu-latest
    outputs:
      services: ${{ steps.services.outputs.services }}
      should-push: ${{ steps.push-decision.outputs.should-push }}
      image-tag: ${{ steps.tag-decision.outputs.image-tag }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Determine services to build
        id: services
        run: |
          SERVICES='["api", "worker", "web"]'
          echo "services=${SERVICES}" >> $GITHUB_OUTPUT

      - name: Determine if we should push
        id: push-decision
        run: |
          SHOULD_PUSH="false"
          
          if [[ "${{ github.event_name }}" == "push" && ("${{ github.ref }}" == "refs/heads/main" || "${{ github.ref }}" == "refs/heads/develop" || "${{ github.ref }}" =~ ^refs/heads/release/ || "${{ github.ref }}" =~ ^refs/tags/v) ]]; then
            SHOULD_PUSH="true"
          elif [[ "${{ github.event_name }}" == "workflow_dispatch" && "${{ github.event.inputs.push_to_registry }}" == "true" ]]; then
            SHOULD_PUSH="true"
          fi
          
          echo "should-push=${SHOULD_PUSH}" >> $GITHUB_OUTPUT
          echo "Will push to registry: ${SHOULD_PUSH}"

      - name: Determine image tag
        id: tag-decision
        run: |
          TAG="latest"
          
          if [[ "${{ github.ref }}" =~ ^refs/tags/v ]]; then
            TAG="${{ github.ref_name }}"
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            TAG="latest"
          elif [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
            TAG="develop"
          elif [[ "${{ github.ref }}" =~ ^refs/heads/release/ ]]; then
            TAG="release-$(echo ${{ github.ref_name }} | sed 's/release\///')"
          elif [[ "${{ github.event_name }}" == "pull_request" ]]; then
            TAG="pr-${{ github.event.number }}"
          elif [[ "${{ github.event_name }}" == "workflow_dispatch" && "${{ github.event.inputs.image_tag }}" != "" ]]; then
            TAG="${{ github.event.inputs.image_tag }}"
          else
            TAG="sha-$(echo ${{ github.sha }} | cut -c1-7)"
          fi
          
          echo "image-tag=${TAG}" >> $GITHUB_OUTPUT
          echo "Using image tag: ${TAG}"

  # ============================================
  # Docker Build & Push
  # ============================================
  docker-build:
    name: Build ${{ matrix.service }}
    runs-on: ubuntu-latest
    needs: prepare-matrix
    strategy:
      fail-fast: false
      matrix:
        service: ${{ fromJson(needs.prepare-matrix.outputs.services) }}
    
    permissions:
      contents: read
      packages: write
      security-events: write
      
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          platforms: linux/amd64,linux/arm64

      - name: Login to GitHub Container Registry
        if: needs.prepare-matrix.outputs.should-push == 'true'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ env.REGISTRY_USERNAME }}
          password: ${{ env.REGISTRY_PASSWORD }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_PREFIX }}-${{ matrix.service }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=semver,pattern={{major}}
            type=raw,value=${{ needs.prepare-matrix.outputs.image-tag }}
            type=raw,value=latest,enable={{is_default_branch}}
            type=sha,prefix={{branch}}-,format=short
          labels: |
            org.opencontainers.image.title=ResumeSync ${{ matrix.service }}
            org.opencontainers.image.description=ResumeSync Pro ${{ matrix.service }} service
            org.opencontainers.image.vendor=ResumeSync
            org.opencontainers.image.version=${{ needs.prepare-matrix.outputs.image-tag }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.created=${{ github.event.head_commit.timestamp }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./apps/${{ matrix.service }}
          file: ./apps/${{ matrix.service }}/Dockerfile
          platforms: linux/amd64,linux/arm64
          push: ${{ needs.prepare-matrix.outputs.should-push }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha,scope=${{ matrix.service }}
          cache-to: type=gha,mode=max,scope=${{ matrix.service }}
          build-args: |
            VERSION=${{ needs.prepare-matrix.outputs.image-tag }}
            BUILD_TIME=${{ github.event.head_commit.timestamp }}
            GIT_COMMIT=${{ github.sha }}
            GIT_BRANCH=${{ github.ref_name }}
          secrets: |
            GIT_AUTH_TOKEN=${{ secrets.GITHUB_TOKEN }}
          provenance: false

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@v0
        with:
          image-ref: ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_PREFIX }}-${{ matrix.service }}:${{ needs.prepare-matrix.outputs.image-tag }}
          format: 'sarif'
          output: 'trivy-${{ matrix.service }}.sarif'
          severity: 'CRITICAL,HIGH'

      - name: Upload Trivy results to GitHub Security
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-${{ matrix.service }}.sarif'
          category: 'docker-${{ matrix.service }}'

      - name: Generate SBOM
        if: needs.prepare-matrix.outputs.should-push == 'true'
        uses: anchore/sbom-action@v0
        with:
          image: ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_PREFIX }}-${{ matrix.service }}:${{ needs.prepare-matrix.outputs.image-tag }}
          format: spdx-json
          output-file: sbom-${{ matrix.service }}.spdx.json

      - name: Upload SBOM
        if: needs.prepare-matrix.outputs.should-push == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: sbom-${{ matrix.service }}
          path: sbom-${{ matrix.service }}.spdx.json

  # ============================================
  # Multi-arch Image Testing
  # ============================================
  test-images:
    name: Test Images
    runs-on: ubuntu-latest
    needs: [prepare-matrix, docker-build]
    if: needs.prepare-matrix.outputs.should-push == 'true'
    strategy:
      matrix:
        service: ${{ fromJson(needs.prepare-matrix.outputs.services) }}
        platform: [linux/amd64, linux/arm64]
    steps:
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ env.REGISTRY_USERNAME }}
          password: ${{ env.REGISTRY_PASSWORD }}

      - name: Test image on ${{ matrix.platform }}
        run: |
          IMAGE="${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_PREFIX }}-${{ matrix.service }}:${{ needs.prepare-matrix.outputs.image-tag }}"
          
          # Test image can be started and is healthy.
          check_health() {
            local url="$1"
            local name="$2"
            local max_retries=12
            local sleep_secs=2
            local i=0
            while [ $i -lt $max_retries ]; do
              status=$(curl -s -o /dev/null -w "%{http_code}" "$url" || true)
              if [[ "$status" =~ ^2 ]]; then
                echo "$name healthy (HTTP $status)"
                return 0
              fi
              echo "$name not ready (HTTP $status), retrying..."
              sleep $sleep_secs
              i=$((i+1))
            done
            return 1
          }

          case "${{ matrix.service }}" in
            api)
              docker run -d --rm --name tmp-${{ matrix.service }} -p 8080:8080 --platform=${{ matrix.platform }} ${IMAGE}
              if ! check_health "http://localhost:8080/health" "API"; then
                echo "API failed readiness checks; dumping logs:"
                docker logs tmp-${{ matrix.service }} || true
                docker stop tmp-${{ matrix.service }} || true
                exit 1
              fi
              docker stop tmp-${{ matrix.service }} || true
              ;;
            web)
              docker run -d --rm --name tmp-${{ matrix.service }} -p 3000:3000 --platform=${{ matrix.platform }} ${IMAGE}
              if ! check_health "http://localhost:3000/api/health" "Web"; then
                echo "Web failed readiness checks; dumping logs:"
                docker logs tmp-${{ matrix.service }} || true
                docker stop tmp-${{ matrix.service }} || true
                exit 1
              fi
              docker stop tmp-${{ matrix.service }} || true
              ;;
            *)
              # CLI or background worker: prefer a deterministic command, try --version then --help
              if docker run --rm --platform=${{ matrix.platform }} ${IMAGE} --version; then
                echo "${{ matrix.service }} responded to --version"
              elif docker run --rm --platform=${{ matrix.platform }} ${IMAGE} --help; then
                echo "${{ matrix.service }} responded to --help"
              else
                echo "${{ matrix.service }} did not start/respond to expected commands. Capturing logs..."
                # Attempt to run detached to capture any logs
                docker run -d --rm --name tmp-${{ matrix.service }} --platform=${{ matrix.platform }} ${IMAGE} || true
                docker logs tmp-${{ matrix.service }} || true
                docker stop tmp-${{ matrix.service }} || true
                exit 1
              fi
              ;;
          esac

  # ============================================
  # Docker Compose Build Test
  # ============================================
  docker-compose-test:
    name: Test Docker Compose Build
    runs-on: ubuntu-latest
    needs: prepare-matrix
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Test Docker Compose build
        run: |
          # Build all services with docker-compose
          docker-compose build --parallel
          
          # Verify images were built
          docker images --filter "reference=*resumesync*"
          
          # Test services can start
          docker-compose up -d
          sleep 30
          
          # Check service health
          docker-compose ps
          
          # Parameterized health checks with retry and HTTP 2xx validation
          API_HEALTH_URL="${API_HEALTH_URL:-http://localhost:8080/health}"
          WEB_HEALTH_URL="${WEB_HEALTH_URL:-http://localhost:3000/api/health}"
          MAX_RETRIES=10
          SLEEP_SECS=3
          check_health() {
            local url="$1"
            local name="$2"
            local retries=0
            while [ $retries -lt $MAX_RETRIES ]; do
              status=$(curl -s -o /dev/null -w "%{http_code}" "$url" || true)
              if [[ "$status" =~ ^2 ]]; then
                echo "$name healthy (HTTP $status)"
                return 0
              fi
              echo "$name not ready (HTTP $status), retrying..."
              sleep $SLEEP_SECS
              retries=$((retries+1))
            done
            # Fallback: check TCP port
            host=$(echo "$url" | awk -F[/:] '{print $4}')
            port=$(echo "$url" | awk -F[/:] '{print $5}')
            if nc -z "$host" "$port"; then
              echo "$name TCP port $port is open, but HTTP check failed."
            else
              echo "❌ $name not reachable after $MAX_RETRIES attempts."
              return 1
            fi
          }
          check_health "$API_HEALTH_URL" "API" || exit 1
          check_health "$WEB_HEALTH_URL" "Web" || exit 1
          
          # Cleanup
          docker-compose down -v
          docker-compose rm -f

  # ============================================
  # Image Size Analysis
  # ============================================
  analyze-images:
    name: Analyze Image Sizes
    runs-on: ubuntu-latest
    needs: [prepare-matrix, docker-build]
    if: needs.prepare-matrix.outputs.should-push == 'true'
    steps:
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ env.REGISTRY_USERNAME }}
          password: ${{ env.REGISTRY_PASSWORD }}

      - name: Analyze image sizes
        run: |
          echo "📊 Docker Image Size Analysis"
          echo "============================="
          
          for service in api worker web; do
            IMAGE="${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_PREFIX }}-${service}:${{ needs.prepare-matrix.outputs.image-tag }}"
            # Check if image exists locally
            if ! docker image inspect ${IMAGE} > /dev/null 2>&1; then
              echo "Image ${IMAGE} not found locally. Attempting to pull from registry..."
              if ! docker pull ${IMAGE}; then
                echo "⚠️  Image ${IMAGE} not found locally or in remote registry. Skipping analysis."
                continue
              fi
            fi
            # Get image info
            SIZE=$(docker image inspect ${IMAGE} --format='{{.Size}}' | numfmt --to=iec)
            LAYERS=$(docker image inspect ${IMAGE} --format='{{len .RootFS.Layers}}')
            CREATED=$(docker image inspect ${IMAGE} --format='{{.Created}}')
            echo ""
            echo "🐳 ${service^^} Service:"
            echo "  Size: ${SIZE}"
            echo "  Layers: ${LAYERS}"
            echo "  Created: ${CREATED}"
            echo "  Image: ${IMAGE}"
            # Analyze layers
            docker history ${IMAGE} --no-trunc --format "table {{.CreatedBy}}\t{{.Size}}" | head -10
          done

      - name: Create size comparison comment
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        continue-on-error: true
        with:
          script: |
            const services = ['api', 'worker', 'web'];
            let sizeReport = `## 📊 Docker Image Size Analysis\n\n| Service | Size | Layers | Registry |\n|---------|------|--------|----------|\n`;
            
            for (const service of services) {
              const image = `${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_PREFIX }}-${service}:${{ needs.prepare-matrix.outputs.image-tag }}`;
              sizeReport += `| ${service} | Computing... | Computing... | [View](https://github.com/${{ github.repository }}/pkgs/container/${{ env.IMAGE_PREFIX }}-${service}) |\n`;
            }
            
            sizeReport += `\n**Tag:** \`${{ needs.prepare-matrix.outputs.image-tag }}\`\n`;
            sizeReport += `**Platforms:** linux/amd64, linux/arm64\n`;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: sizeReport
            });

  # ============================================
  # Build Summary
  # ============================================
  build-summary:
    name: Build Summary
    runs-on: ubuntu-latest
    if: always()
    needs: 
      - prepare-matrix
      - docker-build
      - test-images
      - docker-compose-test
      - analyze-images
    steps:
      - name: Build Summary
        run: |
          echo "🐳 Docker Build Summary"
          echo "======================"
          echo "Services Built: api, worker, web"
          echo "Image Tag: ${{ needs.prepare-matrix.outputs.image-tag }}"
          echo "Registry Push: ${{ needs.prepare-matrix.outputs.should-push }}"
          echo "Docker Build: ${{ needs.docker-build.result }}"
          echo "Image Testing: ${{ needs.test-images.result }}"
          echo "Compose Test: ${{ needs.docker-compose-test.result }}"
          echo "Size Analysis: ${{ needs.analyze-images.result }}"
          echo ""
          
          if [[ "${{ contains(needs.*.result, 'failure') }}" == "true" ]]; then
            echo "❌ Docker build pipeline failed"
            exit 1
          else
            echo "✅ Docker build pipeline completed successfully"
          fi

      - name: Update deployment status
        if: needs.prepare-matrix.outputs.should-push == 'true' && !contains(needs.*.result, 'failure')
        uses: actions/github-script@v7
        with:
          script: |
            // Create deployment status for successful builds
            const deploymentData = {
              ref: context.sha,
              environment: '${{ github.ref_name }}',
              description: 'Docker images built and pushed successfully',
              auto_merge: false
            };
            
            const deployment = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ...deploymentData
            });
            
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: deployment.data.id,
              state: 'success',
              description: 'Images available in registry',
              environment_url: 'https://github.com/${{ github.repository }}/pkgs/container'
            });
